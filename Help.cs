using System;

namespace MatrixCalc
{
    /// <summary>
    /// Справочная информаиця о программе.
    /// </summary>
    public static class Help
    {
        /// <summary>
        /// Находит и выводит справку по указанной теме.
        /// </summary>
        /// <param name="topic"></param>
        public static void ShowHelp(string topic = "")
        {
            // Для удобства сделаем такую функцию с коротеньким именем.
            Action<string> cw = Console.WriteLine;
            topic = topic.Trim();
            switch (topic)
            {
                case "":
                    cw("Легче всего объяснить процесс работы на примерe.");
                    cw("");
                    cw("В переменную `A` поместим матрицу:");
                    cw("   > A = ");
                    cw("   0; 1; 2");
                    cw("   3; 4; -1");
                    cw("   1; 0; -3");
                    cw("Матрицу `B` загрузим из файла (исправьте путь, если нужно):");
                    cw("   > :load ./examples/simple.txt B");
                    cw("Если интересно, то её легко вывести на экран");
                    cw("   > $B");
                    cw("Подробнее про загрузку файлов см. `:help load`");
                    cw("");
                    cw("Теперь можем сделать разные простые вычисления: ");
                    cw("   > $A + $B");
                    cw("   > $A - $B");
                    cw("   > $A * $B");
                    cw("   > $B * 10");
                    cw("Но существуют ещё и несколько более сложных операций:");
                    cw("   > trace $A");
                    cw("   > $A^T");
                    cw("   > det $A");
                    cw("   > solve $A");
                    cw("Если непонятно, что именно делает `^T`, то нужно посмотреть справку:");
                    cw("   > :help ^T");
                    cw("Теперь можно перезаписать матрицу `A` случайной и попробовать выполнить" +
                       "все операции выше ещё раз.");
                    cw("   > A = rand");
                    cw("   ...");
                    cw("");
                    cw("Некоторые особенности:");
                    cw("1. Расчёты ведутся в decimal, которые не обладают бесконечной точности. " +
                       "При реализации алгоритмов почти не принимались меры по уменьшнию накапливающийся ошибки, " +
                       "так что могут быть связанные с этим проблемы.");
                    cw("2. Большие матрицы не выводятся полностью, только некоторая их часть. " +
                       "При разумном использовании это не должно быть заметно, но если всё-таки требуется увидеть " +
                       "всю матрицу, то легче всего сохранить её в файл (cм. :help save) и открыть его в редакторе.");
                    cw("На этом всё. " +
                       "Если хочется узнать о продвинутых возможностях, то наберите :help advanced");
                    return;
                case "advanced":
                    cw("В программе реализован простой парсер сложных выражений. " +
                       "Благодаря этому можно спокойно комбинировать различные операции и группировать их скобками.");
                    cw("Но поскольку он довольно простой, сообщения об ошибках малоинформативны. " +
                       "Если вдруг что-то не получается и непонятно из-за чего, то добавьте больше явных скобочек ;)");
                    cw("Несколько примеров:");
                    cw("   > 2 + 2 * 2");
                    cw("   > 2 * ( det $A + (det $B + 1) ) + 2");
                    cw("");
                    cw("Если посмотреть на `:help commands`, то легко заметить, что для некоторых команд " +
                       "приведено несколько вариантов написания.");
                    cw("Например, `trace $A` и `Tr $a` делают совершенно одно: считают след матрицы.");
                    cw("");
                    cw("Теперь перейдём к типам объектов:");
                    cw("- Обычные числа. " +
                       "Вполне могут заменять единичные матрицы, например, при сложении матрицы и числа.");
                    cw("   > $A + 1");
                    cw("- Единичные матрицы. " +
                       "Почти что обычные матрицы, но бесконечного размера и с определённым содержимым. " +
                       "На них легко умножать и их легко прибавлять. Создаются при помощи команды `E` (см. :help E)");
                    cw("   > E");
                    cw("   > 42E");
                    cw("- Матрицы. Самые обычные матрицы вещественных чисел, ничего особенного и неожиданного. " +
                       "Можно либо загрузить из файла, либо ввести вручную, либо получить в результате вычислений.");
                    cw("   > E3");
                    cw("   > 42E7");
                    cw("- Переменные. Могут хранить любые вышеперечисленные значения и быть сохранены в файл. " +
                       "Имена переменных могут состоять только из букв и символов подчеркивания; " +
                       "чувствительны к регистру.");
                    cw("   > a = 1");
                    cw("   > VeryBig = E9999");
                    cw("Некоторые интересные особенности:");
                    cw("- Операция присваивания «возвращает» присвоенное значение. " +
                       "Поэтому вполне возможно написать что-то такое:");
                    cw("   > a = 1 + (b = 1 + (c = 1))");
                    cw("После этого переменные `a`, `b`, `c` примут значения 3, 2, 1 соответственно.");
                    cw("- Если вы дошли до этого места, до достойны знать, что последнее вычисленное " +
                       "значение автоматически помещается в переменную `_`");
                    cw("   > 1 + 2");
                    cw("   > $_ + 3");
                    cw("   6");
                    cw("- В файлах можно определять переменные с некорректными именами. " +
                       "Это не приводит ни к чему плохому, просто к ним нельзя получить доступ из программы.");
                    return;
                case "load":
                case ":load":
                case "save":
                case ":save":
                    cw("# Сохранение и загрузка файлов.");
                    cw("Обе команды (:load, :save) обладают похожим синтаксисом.");
                    cw("   > :save File.txt varA varB");
                    cw("   > :load File.txt varA varB");
                    cw("Эти две команды сначала записывают переменные `varA` и `varB` " +
                       "в файл File.txt, а потом загружают их оттуда же.");
                    cw("Можно спокойно опустить список переменных. Тогда будут загружены/сохранены " +
                       "все возможные переменные.");
                    cw("   > :save All.txt");
                    cw("   > :load examples/slau.txt");
                    cw("   > solve $slau_A");
                    goto case "format";
                case "format":
                    cw("# Формат файла.");
                    cw("В файле разрешены однострочные комментарии (строки, начинающиеся с # или //) " +
                       "и пустые строки везде, кроме значений матрицы.");
                    cw("## Задание матрицы");
                    cw("   Matrix {имя переменной} {кол-во строк} {кол-во столбцов}");
                    cw("   ...");
                    cw("   \\n");
                    cw("Объявление матрицы начинается со слова Matrix, за которым следует имя переменной, " +
                       "а затем число строк и столбцов.");
                    cw("На следующих строках задаются занчения матрицы. " +
                       "Каждая строка должна состоять из указанного количества чисел — по одному на столбец.");
                    cw("Числа разделяются одиночными пробелами, " +
                       "но я рекомендую использовать символ \\t, если редактор корректно его поддерживает");
                    cw("После последней строки матрицы должна *обязательно* находиться пустая строка. " +
                       "Даже если это конец файла.");
                    cw("");
                    cw("Поскольку я описал всё необходимое для соответствующего критерия, дальше буду краток.");
                    cw("- Число:");
                    cw("   Number {имя переменной} {значение}");
                    cw("- Единичная матрица:");
                    cw("   IdentityMatrix {имя переменной} {значение чисел на диагонали}");
                    cw("- Решение СЛАУ: аналогично обычной матрице, но вместо `Matrix` нужно написать `Solution`. " +
                       "Настоятельно рекомендуется в таком случае указывать матрицу в каноническом виде, но это " +
                       "не является необходимым");
                    cw("");
                    cw("Если вдруг что-то непонятно, то всегда можно поместить значение в переменную, " +
                       "а потом при помощи `:save test.txt var` записать его в файл, " +
                       "который можно просто открыть и посмотреть.");
                    return;
                case "exit":
                case ":exit":
                    cw("Чтобы выйти из программы введите «:exit» и нажмите Enter.");
                    return;
                case "help":
                case ":help":
                    cw("Команда :help позволяет получить справку о всех возможностях MatrixCalc.");
                    cw("- `:help` — небольшое описание того, как эта программа вообще работает.");
                    cw("- `:help :help` — выводит эту справку.");
                    cw("- `:help :exit` — подробно описывает как выйти из программы.");
                    cw("- `:help :load` — рассказывает о том, как загружать данные из файлов (и сохранять).");
                    cw("- `:help format` — описание формата данных.");
                    cw("- `:help commands` — краткое описание всех операторов.");
                    cw("- `:help <command>` — подробное описание той или иной команды.");
                    return;
                case "command":
                case "commands":
                case "operator":
                case "operators":
                    foreach (var command in Command.FlatCommands)
                    {
                        ShowHelp(command, true);
                    }

                    return;
                default:
                    ShowHelpForCommand(topic);
                    return;
            }
        }

        /// <summary>
        /// Находит и выводит справку по указанной команде.
        /// </summary>
        /// <param name="query">Имя команды, которую надо найти.</param>
        private static void ShowHelpForCommand(string query)
        {
            var found = false;
            foreach (var command in Command.FlatCommands)
            {
                foreach (var syntax in command.CompiledSyntax)
                {
                    var comparisonType = syntax.Flags.CaseInsensitive
                        ? StringComparison.InvariantCultureIgnoreCase
                        : StringComparison.InvariantCulture;
                    if (string.Equals(syntax.Command, query, comparisonType))
                    {
                        ShowHelp(command);
                        found = true;
                        break;
                    }
                }
            }

            if (!found)
            {
                Console.WriteLine($"Не нашлось справки про `{query}`. Попробуйте набрать `:help help`");
            }
        }

        /// <summary>
        /// Выводит справку по переданной команде.
        /// </summary>
        /// <param name="small">Использовать ли краткий формат справки.</param>
        private static void ShowHelp(Command command, bool small = false)
        {
            Console.Write($"{command.Title}");
            if (!small)
            {
                Console.WriteLine();
                Console.Write("Варинаты написания:".IndentLines());
            }

            foreach (var s in command.CompiledSyntax)
            {
                var left = "";
                if (s.Left != null)
                {
                    left = s.Left + " ";
                }

                var right = "";
                if (s.Right != null)
                {
                    right = " " + s.Right;
                }

                Console.Write($"\t`{left}{s.Command}{right}`; ");
            }

            Console.Write(Environment.NewLine);

            if (!small)
            {
                Console.WriteLine(command.Description.IndentLines());
            }
        }
    }
}